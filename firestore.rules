rules_version = '2';
// HARDENED V1 RULES - Last updated: 2025-12-14
// Principle: default-deny, tenant data Functions-only, frozen ownership fields
service cloud.firestore {
  match /databases/{database}/documents {

    // ========================================
    // HELPER FUNCTIONS
    // ========================================
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isAdmin() {
      return request.auth != null && request.auth.token.admin == true;
    }

    // Validate booking exists before get()
    function bookingExists(bookingId) {
      return bookingId is string
        && exists(/databases/$(database)/documents/bookings/$(bookingId));
    }

    // ========================================
    // DEFAULT DENY (catch-all)
    // ========================================
    match /{document=**} {
      allow read, write: if false;
    }

    // ========================================
    // PUBLIC DISCOVERY DATA (public read, admin write)
    // NOTE: Admin writes allowed during transition. Target: migrate to /v1/admin/* API then lock to false.
    // ========================================

    match /listings/{listingId} {
      allow read: if true;
      allow create, update, delete: if isAdmin();
      
      // Catalog data subcollections (menuItems, services, offerings, tickets, roomTypes)
      match /{kind}/{itemId} {
        allow read: if true;
        allow create, update, delete: if isAdmin();
      }
    }

    // Market-level catalog ingest infrastructure (admin-only)
    match /markets/{marketId}/catalogIngestJobs/{jobId} {
      allow read: if isAdmin();
      allow write: if isAdmin();
    }
    match /markets/{marketId}/catalogIngestProposals/{proposalId} {
      allow read: if isAdmin();
      allow write: if isAdmin();
    }
    match /places/{id} { allow read: if true; allow create, update, delete: if isAdmin(); }
    match /events/{id} { allow read: if true; allow create, update, delete: if isAdmin(); }
    match /activities/{id} { allow read: if true; allow create, update, delete: if isAdmin(); }
    match /experiences/{id} { allow read: if true; allow create, update, delete: if isAdmin(); }
    match /trips/{id} { allow read: if true; allow create, update, delete: if isAdmin(); }
    match /stays/{id} { allow read: if true; allow create, update, delete: if isAdmin(); }
    match /connectCuration/{id} { allow read: if true; allow create, update, delete: if isAdmin(); }
    match /hotZones/{id} { allow read: if true; allow create, update, delete: if isAdmin(); }
    
    // Discover config (regions, categories etc)
    match /discover/{document=**} {
      allow read: if true;
      allow write: if isAdmin();
    }

    // App config (discover settings, homepage config etc)
    match /appConfig/{document=**} {
      allow read: if true;
      allow write: if isAdmin();
    }

    // ========================================
    // USER-OWNED DATA
    // ========================================

    match /users/{userId} {
      allow read: if isAuthenticated() && isOwner(userId);
      allow create: if isAuthenticated() && isOwner(userId) &&
        (!request.resource.data.keys().hasAny(['role', 'admin', 'accessLevel']));
      allow update: if isAuthenticated() && isOwner(userId) &&
        (!request.resource.data.diff(resource.data).affectedKeys().hasAny(['role', 'admin', 'accessLevel']));
      allow delete: if false;
    }

    // User profiles for social features
    match /socialUsers/{userId} {
      allow read: if true;
      allow write: if isAuthenticated() && isOwner(userId);
    }
    // Legacy duplicate (explicit deny until migration)
    match /social_users/{userId} {
      allow read: if true;
      allow write: if isAuthenticated() && isOwner(userId);
    }

    // Notifications - BIND to caller, FREEZE userId on update
    match /notifications/{notificationId} {
      allow read: if isAuthenticated() && isOwner(resource.data.userId);
      // Create MUST bind userId to caller
      allow create: if isAuthenticated() 
        && request.resource.data.userId == request.auth.uid;
      // Update/delete must match AND freeze userId
      allow update: if isAuthenticated() 
        && isOwner(resource.data.userId)
        && request.resource.data.userId == resource.data.userId;
      allow delete: if isAuthenticated() && isOwner(resource.data.userId);
    }

    // Itineraries - FREEZE userId on update
    match /itineraries/{itineraryId} {
      allow read: if isAuthenticated() && (isOwner(resource.data.userId) || resource.data.isPublic == true);
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() 
        && isOwner(resource.data.userId)
        && request.resource.data.userId == resource.data.userId;
      allow delete: if isAuthenticated() && isOwner(resource.data.userId);
      match /items/{itemId} {
        allow read, write: if isAuthenticated() && isOwner(get(/databases/$(database)/documents/itineraries/$(itineraryId)).data.userId);
      }
    }

    // ========================================
    // SOCIAL / CONNECT FEATURES
    // ========================================

    // Anchors - BIND to caller on create
    match /anchors/{anchorId} {
      allow read: if true;
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && isOwner(resource.data.userId);
    }

    // Check-ins (standardized collection)
    match /checkins/{checkinId} {
      allow read: if true;
      allow create: if isAuthenticated() 
        && request.resource.data.userId == request.auth.uid
        && !request.resource.data.keys().hasAny(['expiresAt']);
      allow delete: if isAuthenticated() && isOwner(resource.data.userId);
    }
    // Legacy camelCase (explicit rule)
    match /checkIns/{checkinId} {
      allow read: if true;
      allow create: if isAuthenticated() 
        && request.resource.data.userId == request.auth.uid
        && !request.resource.data.keys().hasAny(['expiresAt']);
      allow delete: if isAuthenticated() && isOwner(resource.data.userId);
    }

    // User activities - BIND hostUserId to caller
    match /userActivities/{activityId} {
      allow read: if true;
      allow create: if isAuthenticated() && request.resource.data.hostUserId == request.auth.uid;
      allow update: if isAuthenticated() && (
        // Host can update all
        resource.data.hostUserId == request.auth.uid ||
        // Others can only update RSVP fields
        request.resource.data.diff(resource.data).affectedKeys()
          .hasOnly(['goingUserIds', 'interestedUserIds', 'goingCount', 'interestedCount', 'updatedAt'])
      ) && request.resource.data.hostUserId == resource.data.hostUserId; // FREEZE hostUserId
      allow delete: if isAuthenticated() && resource.data.hostUserId == request.auth.uid;
    }

    // Joins/RSVPs
    match /joins/{joinId} {
      allow read: if true;
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // Event attendees
    match /eventAttendees/{attendeeId} {
      allow read: if true;
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update: if isAuthenticated() 
        && resource.data.userId == request.auth.uid
        && request.resource.data.userId == resource.data.userId; // FREEZE
      allow delete: if isAuthenticated() && resource.data.userId == request.auth.uid;
    }

    // ========================================
    // BOOKINGS - FREEZE userId on update
    // ========================================

    match /bookings/{bookingId} {
      allow read: if isAuthenticated() && (resource.data.userId == request.auth.uid || isAdmin());
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      // CRITICAL: Freeze userId on update - owner cannot transfer booking
      allow update: if isAuthenticated()
        && (resource.data.userId == request.auth.uid || isAdmin())
        && request.resource.data.userId == resource.data.userId;
      allow delete: if isAuthenticated() && (resource.data.userId == request.auth.uid || isAdmin());
    }

    // Booking communications - GUARD bookingId existence
    match /bookingCommunications/{commId} {
      function isBookingParticipant() {
        return isAuthenticated()
          && bookingExists(resource.data.bookingId)
          && (isAdmin() ||
              get(/databases/$(database)/documents/bookings/$(resource.data.bookingId)).data.userId == request.auth.uid);
      }
      
      allow read: if isBookingParticipant();
      allow create: if isAuthenticated()
        && bookingExists(request.resource.data.bookingId)
        && get(/databases/$(database)/documents/bookings/$(request.resource.data.bookingId)).data.userId == request.auth.uid;
      allow update, delete: if isAdmin();
    }

    // ========================================
    // GENERAL CHAT (user-owned sessions)
    // NOTE: Client must create session BEFORE messages (no batch)
    // ========================================

    match /chatSessions/{sessionId} {
      allow read: if isAuthenticated() && resource.data.userId == request.auth.uid;
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid;
      allow update, delete: if false;

      match /messages/{messageId} {
        function isSessionOwner() {
          return isAuthenticated()
            && get(/databases/$(database)/documents/chatSessions/$(sessionId)).data.userId == request.auth.uid;
        }
        allow read: if isSessionOwner();
        allow create: if isSessionOwner();
        allow update, delete: if false;
      }
    }

    // ========================================
    // TENANT DATA: FUNCTIONS-ONLY
    // ========================================

    match /businesses/{businessId}/{doc=**} { allow read, write: if false; }
    match /business_configs/{id} { allow read, write: if false; }
    match /business_chat_sessions/{id} { allow read, write: if false; match /messages/{msgId} { allow read, write: if false; }}
    match /business_bookings/{id} { allow read, write: if false; }
    match /business_enquiries/{id} { allow read, write: if false; }
    match /business_knowledge/{id} { allow read, write: if false; }
    match /business_products/{id} { allow read, write: if false; }
    match /clients/{id} { allow read, write: if false; }
    match /campaigns/{id} { allow read, write: if false; }
    match /requests/{id} { allow read, write: if false; }
    match /conversations/{id} { allow read, write: if false; }

    // Multi-business infrastructure (Functions-only writes)
    // userBusinesses: index of businesses a user belongs to
    match /userBusinesses/{uid} {
      allow read: if isAuthenticated() && isOwner(uid);
      allow write: if false; // Functions-only
      match /businesses/{businessId} {
        allow read: if isAuthenticated() && isOwner(uid);
        allow write: if false;
      }
    }

    // entitlements: user limits and billing (Functions-only writes)
    match /entitlements/{uid} {
      allow read: if isAuthenticated() && isOwner(uid);
      allow write: if false; // Functions-only (Stripe webhook sets these)
    }

    match /taxi_drivers/{id} { allow read, write: if false; }
    match /taxi_requests/{id} { allow read, write: if false; }

    // ========================================
    // JOBS API (Sprint 1)
    // ========================================

    match /jobs/{jobId} {
      // 1. Read: Owner only
      allow read: if isAuthenticated() && isOwner(resource.data.ownerUserId);

      // 2. Create: Owner only + must be 'collecting' status
      allow create: if isAuthenticated()
        && request.resource.data.ownerUserId == request.auth.uid
        && request.resource.data.status == 'collecting';

      // 3. Update: Owner only + Immutable Critical Fields
      // Clients CANNOT change: status, merchantTarget, timestamps, or transfer ownership
      allow update: if isAuthenticated()
        && isOwner(resource.data.ownerUserId)
        && request.resource.data.ownerUserId == resource.data.ownerUserId // No ownership transfer
        && !request.resource.data.diff(resource.data).affectedKeys()
            .hasAny(['status', 'confirmingAt', 'dispatchedAt', 'confirmedAt', 
                     'cancelledAt', 'completedAt', 'merchantTarget', 'jobCode']);

      // 4. Delete: Deny (Jobs are permanent records)
      allow delete: if false;
    }
  }
}
